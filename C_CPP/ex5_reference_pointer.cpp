//주석달기 ctrl+k, ctrl+c
//주석해제 ctrl+k, ctrl+u

//1. 이름과 점수를 입력받고, 다음과 같이 출력되는 프로그램을 작성하시오.
//이름입력: 두들낙서
//점수입력: 89
//두들낙서님의 점수는 89점입니다.

//2. 이차원 배열 출력해보기

#include <iostream>
#include <string>

using namespace std;


int main_2dim_array() {
	string name;
	int score;

	cout << " 이름입력 :";
	cin >> name;
	cout << "점수 입력 : ";
	cin >> score;
	cout << name << "님의 점수는 " << score << " 점 입니다." << endl;

	// 범위기반 for 문 사용해서 2차원배열 출력하기

	int arr[2][3] = { {1,2,3},{4,5,6} };

	//=========여러가지 시도==================================
	// 시도 1 >> 에러 : n이 int 포인터여야 함.
	//for (int n : arr) {
	//	cout << n << endl;
	//}


	//시도 2 >>
	for (int* n : arr) {
		cout << *n << endl;
	}
	// 출력값 1 4  
	// 각 행의 0번째 요소 출력됨
	// 배열 이름쓰면 그 주소값이 각 배열의 0번째 요소


	// 시도3 >> 완전 틀린 풀이
	//for (int* n : arr) {
	//	for (int m : n) {
	//		cout << m << ' ';
	//	}
	//}


	// 시도 4 >>
	// 이렇게는 출력은 되지만 우리가 원하는것은
	// 범위 기반 for 문만 사용하는 것
	//for (int* n : arr) {
	//	for (int i = 0; i < 3; i++) {
	//		cout << n[i] << ' ';
	//	}
	//}
	// 이것도 출력은 정상적으로 안됨
	//========================================================


	// 모범답안
	//===============1,2 for 문은 본질적으로는 비슷함 =====
	// 1. 범위기반 for문: 배열에 대한 <<< 레퍼런스 >>>를 써야함, 
	// 배열포인터 사용과 원리 비슷
	// 3개짜리 배열을 가리키는 인트형 변수 ln 을 만들겠다.
	// 레퍼런스 변수 사용할 때는 변수 이름만 적어도 가리키는 대상이라 
	// 사용할 때 & 안붙이고 이름만 써도 됨 ln
	for (int(&ln)[3] : arr) {
		for (int& col : ln) {
			cout << col << ' ';
		}
		cout << endl;
	}
	// auto 로 더 간편하게 많이 사용함
	for (auto& ln : arr) {
		for (auto& col : ln) {
			cout << col << ' ';
		}
		cout << endl;
	}
	// 2. 배열포인터 사용해 2차원 배열 각 요소를 각각 출력함
	// 3개 짜리 인트형 배열을 가리키는 포인터 ln을 만들고, arr 저장해줌
	// 포인터를 사용할 때는 *해줘야 대상을 가리킴 *ln
	// 각 차원의 배열 갯수만큼 증가하면서 for loop
	for (int(*ln)[3] = arr; ln < arr + 2; ln++) {
		for (int* c = *ln; c < *ln + 3; c++) {
			cout << *c << ' ';
		}
		cout << endl;
	}
	//==========================================================================
	/*포인터와 레퍼런스 차이
	포인터 : 단순히 주소값의 복사 - 주소 가리키는 대상을 변경하지 못함
	int* p; 는 int형 변수의 주소를 저장하는 포인터(변수)p를 선언
	레퍼런스: 원본 접근 가능
	
	int* ptr = &num 
	포인터 변수 ptr이 stack 에 4바이트 공간으로 존재,
	변수 num의 주소를 가지고 있음.
	반면 레퍼런스는 num 이란 변수의 메모리 공간에 ref라는 이름만 하나 더 생기는 것

	ptr == &num
	&ptr != &num
	가리키는 주소값은 같아도 포인터변수 주소값과 대상의 주소값은 다르다.
	
	하지만 레퍼런스는 동일
	ref == num
	&ref == &num

	내부적인 전달방식엔 차이 없지만,레퍼런스가 등장한 이유
	1. 포인터는 주소를 가리키지만 널 NULL 을 가리킬 수 있음 
		유효하지 않은 공간 가리키니 에러 (세그멘테이션 오류, 프로그램 충돌..)
	2. 포인터는 전달받은 주소에 가감하여 다른 주소에 접근 가능해 유용한데, 
		반대로 이 이유로 접근하지 말아야 할 메모리에 접근하여 값을 건드릴 위험.
		
	이런 위험 없애고 포인터 기능 그대로 사용하게 만든것이 레퍼런스
	주소통해 원본 접근 가능하지만, 대상,원본,주소 변경은 못하게 함.
	레퍼런스는 NULL 을 아예 참조할 수 없음.

	가리키는 대상을 바꿀 수 있어야 하면 포인터 사용, 
	가리키는 대상 절대 변하지 않는다면 레퍼런스 사용 권장


	*/
	
	return 0;

}